• Instituicao:           	UNIVERSIDADE FEDERAL DE SENTA CATARINA.
• Departamento:          	INE - DEPARTAMENTO DE INFORMÁTICA E ESTATÍSTICA.
• Graduandos:             	LUCAS FINGER ROMAN (13103523).
						  	RODRIGO PEDRO MARQUES (12200660).
• Data:                   	FLORIANÓPOLIS, 05 DE NOVEMBRO DE 2015.

• Linguagem Utilizada:    	Java.
• IDE Utilizada:			Eclipse.
• Link do projeto:			https://github.com/lucas-roman/Trabalho_Formais.git

• TRABALHO II: CONSTRUÇÃO DE UM ANALISADOR LÉXICO

- INTRODUÇÃO
	Para a construção de um analisador léxico foi necessário fazeer a implementação de um algoritmo de minimização
	de autômatos. Foi necessário também fazer um algoritmo de união de autômatos que será explicado mais a frente.
	
- DESENVOLVIMENTO
	Foi nos requisitados a criação de uma linguagem simples com alguns requisitos, são eles:
	. Conter pelo menos uma estrutura de repetição e uma estrutura condicional.
		Para este item, nós escolhemos fazer as estruturas 'while' e 'for' como estrutura de repetições, e a estrutura
		condicional escolhida foi a 'if'.
		
	. Aceitar comandos de leitura e escrita.
		Nós escolhemos o comando 'read' e 'write', onde um lê e o outro escreve respectivamente.
	
	. Aceitar operações algébricas simples.
		Escolhemos os símbolos padrões para a representação de cada operação. Símbolo '+' para soma; símbolo '-' para subtração
		e assim por diante.
	
	. Aceitar declarações e operações de estruturas do tipo "array" unidimensional e multidimensional.
		A nossa linguagem só irá aceitar arrays dos tipos: int,string,float,char,bool.
	
	. Aceitar comandos de comparação.
		Os comandos de comparações que a nossa linguagem possui são: diferente (!=), maior ou igual (>=), menor ou igual (<=),
		igual (==), maior (>) e menor (<),
	
	. Aceitar operadores lógicos.
		Os operadores lógicos aceitos pela nossa linguagem são: e (and), or (ou) e negação (not).

	. Aceitar escrita de strings.
		Basta iniciar a declaração da string com "string nome_da_variavel = alguma sentenca" (sem aspas). Nós ainda iremos definir
		melhor esta declaração mais a frente.
	
	. Nome das variáveis pode ser feito usando "_".
		Ok.
	
	. Deve permitir declaração de constantes numéricas e booleanas.
		A linguagem irá aceitar tipos de constantes int,string,float,char,bool.
		
- ALGORITMOS

	É possível encontrar o algoritmo de minimização na classe: /Trabalho_Formais/src/main/lexer/automata/MinimizeComputer.java.
	
	Os algoritmos de operações sobre autômatos (fechamento, união e concatenação) podem ser encontrados na classe: /Trabalho_Formais/src/main/lexer/automata/AutomataSkeleton.java
	Os algoritmos são explicados brevemente na interface /Trabalho_Formais/src/main/lexer/automata/Automata.java.
	
	A classe principal se encontra em: /Trabalho_Formais/src/main/lexer/model/commandline/main/Main.java.
	Nela há uma breve explicação de como funciona o programa.
	
	- Sistemas de TAGS:
		Os estados são marcados com tags. Assim, quando uma palavra for lida pelo autômato, o estado que ele estiver depois de ter a entrada toda lida terá seu tag como a categoria
                da palavra segundo o autômato. Para implementar isso, foram usados os seguintes conceitos:
                1 - Na união:
                    Cada estado de aceitação do autômato resultante terá o mesmo tag que ele tinha antes da união no seu antigo autômato.
                2 - Na concatenação:
                    Os estados do autômato à esquerda não recebem tags. Os estados do autômato da direita recebem como tag o valor anterior.
                3 - No fechamento:
                    Os estados mantém suas tags.
                4 - Na conversão de não determinístico para determinístico:
                    Como cada estado do autômato finito determinístico resultante é igual a um conjunto de estados do autômato finito não determinístico, a tag do novo estado será
                    igual à tag com maior precedência dentre todas as tags dos estados do autômato não determinístico que está sendo convertido.
                    Exemplo:
                        Tag(q3) = IF
                        Tag(q4) = ID
                        Tag(q3,q4) = IF, pois na lista de entrada IF tem uma precedência maior que ID.
                - Lista de entrada:
                	Definida no arquivo da linguagem da seguinte forma: as expressões regulares que são definidas mais acima no arquivo tem uma precedência maior que as definidas
                        mais abaixo.
		Todos os estados que não tiverem são aceitadores receberão a tag ERROR. Se o estado não possui transição pela próxima letra, a tag resultante será ERROR.
	

- USANDO O PROGRAMA

	Para usar o programa, e necessario chama-lo pela linha de comando da seguinte forma:
        
	java -jar AnalisadorLexico.jar 

	O programa aceita 2 argumentos, sendo o primeiro obrigatorio e o segundo opcional. São eles:

	1 - O arquivo a ter a estrutura analisada. Se for chamado sozinho, o programa entao criara um automato para reconhecer a linguagem atraves do arquivo
		 lang.aut. Se o arquivo nao existir, o programa pedira que seja entrado o caminho para o arquivo que descreve a linguagem. No caso do trabalho, 
		 este arquivo é ./lang/pikachu.ash.
    2 - O arquivo que contém a estrutura da linguagem a ser usada para analisar o fonte.
    
    Depois de rodar o AnalisadorLexico.jar, o programa ira criar o lang.aut e o analyze.out. O arquivo 'lang.aut' representa o automato da linguagem.
    Ele e criado para melhorar o desempenho do programa em analises futuras.
    O analyze.out contera os tokens do programa fonte analisado.
    
- CONSTRUINDO A LINGUAGEM

	O arquivo que define a linguagem deve estar organizado da seguinte forma:
	TAG1
	EXPRESSÃO REGULAR QUE RECONHECE A TAG1
	
	TAG2
	EXPRESSÃO REGULAR QUE RECONHECE A TAG2

        ...

        TAGN
	EXPRESSÃO REGULAR QUE RECONHECE A TAGN

	Pode haver linhas em branco entre a declaração dos blocos TAG EXPRESSÃOREGULAR, mas não no meio deste. Em caso de conflito entre as tags de diferentes expressões regulares, 
        a tag resultante será a que foi declarada mais acima no arquivo.


• MANUAL PARA A LINGUAGEM PIKACHU.ash:

	A linguagem pikachu.ash pode ser encontrada no caminho: /Trabalho_Formais/lang/pikachu.ash.
	
	- Todo programa deve ter a seguinte estrutura:
	
		program nome_do_programa begin
		    corpo do programa
		.
	
	O corpo do programa deve conter funcoes que poderao ser chamadas pelo programa.
	Tudo que nao estiver dentro do corpo de funcao sera considerado como um metodo main.
	
	- Funcoes podem ser declaradas da seguinte forma:
	
		funct TYPE nome_da_funcao ( param1 , param2 , param3 ) begin
		    corpo da funcao
		end
	
	- Utilizando as construcoes da linguagem:
	
	As palavras begin e end servem para abrir e fechar os blocos respectivamente.
		if => if ( condicao ) begin
		          corpo do if
		      end
		
		if else => if ( condicao) begin
		               corpo do if
		           else
		               corpo do else
		           end
	
		for => for ( int ID = NUMBER|ID to NUMBER|ID ) begin
		           corpo do for
		       end
	
		while => while ( cond ) begin
		             corpo do while
		         end
	
		read => read ( "filename" ) ;
	
		write => write ( "filename" , ID|STRING ) ;
	
	- Constantes booleanas:
		true e false.
	
	- Comparacoes booleanas:
		== <= >= < > not and or != 
	
	- Tipos:
		int, char, bool, float, string.
		OBS: A implementar: RE que reconheca float.
			
	- = => assign
	
	- Numeros:
		0 ou qualquer numero de 1 ou mais digitos que nao comece com 0.
	
	- IDs podem ser construidos comecando por _ ou qualquer letra, seguidos 
	  de letras ou _ ou numeros.
	
	- Operadores matematicos:
		+ - * /
	
	- Arrays:
		Tipos seguidos de 1 ou mais colchetes [].
		OBS: Arrays em si sao outros tipos.
	
	- Sobre as construcoes da linguagem:
	
			Os Tokens deverao ser separados por espacos em brancos nessa versao da 
		linguagem. Por exemplo: funct myFunct(int x) begin deve ser construida assim
		funct myFunct ( int x ) begin
		
		Todo statement, a nao ser aquele que seja . ou seja abertura ou fechamento
		de bloco (statements declarativos) devem ter um ponto e virgula no final.
	
	- Sobre constantes de STRING:
	
			Do jeito que os tokens estao sendo passados para o analisador,
		o programa nao aceita strings com espacos no meio, pois na hora de passar os tokens
		o INPUT esta quebrando o programa em espacos em branco. Isto sera melhorado mais adiante.
		Caracteres aceitos em constantes de String: qualquer letrado alfabeto ingles ou _ ou 
		qualquer numero ou . ou + ou - ou * ou / ou ?.
		Esses problemas serao corrigidos em versoes futuras.
